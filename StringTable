//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
	Record[] table;
	int records;
	//
	// Create an empty table big enough to hold maxSize records.
	//
	public StringTable(int maxSize) 
	{
		table = new Record[2]; //2^1 slots
		records = 0;
	}


	//
	// Insert a Record r into the table.  Return true if
	// successful, false if the table is full.  You shouldn't ever
	// get two insertions with the same key value, but you may
	// simply return false if this happens.
	//
	public boolean insert(Record r) 
	{ 
		if((double)records/table.length >= 0.25) { //if load factor reaches 1/4, double array length
			doubleSize();
		}
		if(r!=null){
 			int hash = baseHash(r.hashKey);
			while(table[hash] != null && !table[hash].key.equals("deleted")) { //loops as long as the slot is full
				if(table[hash]==r) //checks for duplicates
					return false;
//							System.out.println("inside insert while loop");
 			hash = (hash + stepHash(r.hashKey)) % table.length; //step fxn
			}
			table[hash] = r; //actual insert at hash value where slot is "deleted" or null
	//		System.out.println("inserted at " + hash);
			records++;
		}
//		System.out.println("load factor "+(double)records/table.length);
 		
		return true; 
	}


	//
	// Delete a Record r from the table.  Note that you'll have to
	// find the record first unless you keep some extra information
	// in the Record structure.
	//
	public void remove(Record r) 
	{
		if(r!=null){
			int hash = baseHash(r.hashKey);
			int count = 0;
			while(count<table.length) {
				if(table[hash]==r) { //remove record if it matches
					table[hash].key = "deleted";
					count = table.length; //ends loop
					records--;
					//System.out.println("deleted at " + hash);
 				}
				else if(table[hash]==null){ //record doesn't exist in table
					count = table.length; //ends loop
				}
				else {
					hash = (hash + stepHash(r.hashKey)) % table.length; //step fxn
					count++;
				}
			}
		}
	}


	//
	// Find a record with a key matching the input.  Return the
	// record if it exists, or null if no matching record is found.
	//
	public Record find(String key) 
	{
		int hash = baseHash(toHashKey(key));
		int count = 0;
		while(count < table.length) {
			if(table[hash]==(null)) //not in table
			{
			//	System.out.println("I didn't find it at "+ hash);
				return null;
			}
			else {
				if(table[hash].key.equals(key)) //actual find
 					return table[hash];
				hash = (hash + stepHash(toHashKey(key))) % table.length; //step fxn
			}
			//System.out.println("I am looking at " + hash);
			count++;
		}
		return null;
	}
//GOOD
 	public void doubleSize() {
		System.out.println("table was doubled");
		int count = 0; 
 		Record[] oldTable = new Record[table.length];
		for(int i = 0; i<oldTable.length; i++) {
			oldTable[i]=table[i];
		}
		table = new Record[oldTable.length * 2];
		records = 0;
		for(int i = 0; i<oldTable.length; i++) {
			if(oldTable[i]!=null && !oldTable[i].key.equals("deleted")){
				insert(oldTable[i]);
				count ++;
 				
			}
		}

	}


	///////////////////////////////////////////////////////////////////////


	// Convert a String key into an integer that serves as input to hash
	// functions.  This mapping is based on the idea of a linear-congruential
	// pesudorandom number generator, in which successive values r_i are 
	// generated by computing
	//    r_i = ( A * r_(i-1) + B ) mod M
	// A is a large prime number, while B is a small increment thrown in
	// so that we don't just compute successive powers of A mod M.
	//
	// We modify the above generator by perturbing each r_i, adding in
	// the ith character of the string and its offset, to alter the
	// pseudorandom sequence.
	//
	static int toHashKey(String s)
	{
		int A = 1952786893;
		int B = 367257;
		int v = B;

		for (int j = 0; j < s.length(); j++)
		{
			char c = s.charAt(j);
			v = A * (v + (int) c + j) + B;
		}

		if (v < 0) v = -v;
		return v;
	}

	int baseHash(int hashKey){
		double a = (Math.sqrt(5.0)-1)/2;
		double frac = (hashKey * a) - (int)(hashKey * a);
		int hashValue = (int) (table.length * frac);
		return hashValue;                                
	    }
	    // 
	    // Step hash function which is designed to be odd to ensure the program checks every
	    // space of the table
	
    int stepHash(int hashKey){
	    	double a= hashKey * (Math.E/4);
	    	int h2 = (int)( Math.floor(table.length* (a-Math.floor(a))));
	    	if(h2%2==0)
	    	{
	    		return h2+5;
	    	}
	        return h2;
	        
	    }
	     
}
